"""Thermal Regulation System — Custom Gymnasium Environment.

Simulates an avionics electronic box with active fan cooling.  The agent
chooses a discrete fan-speed level each time-step.  The goal is to keep
the component temperature within a safe operating band while minimising
energy consumption.

Physics model: simplified **lumped-capacitance** thermal network.

    C · dT/dt  =  Q_gen(t) − (T − T_amb)/R − Q_fan(action)

where
    C      = thermal mass  (J/°C)
    R      = passive thermal resistance  (°C/W)
    Q_gen  = heat generated by the chip (time-varying workload)
    Q_fan  = cooling power of the selected fan speed
    T_amb  = ambient temperature (with optional disturbances)
"""

from __future__ import annotations

from typing import Any

import gymnasium as gym
import numpy as np
from gymnasium import spaces


class ThermalControlEnv(gym.Env):
    """Custom Gymnasium environment for avionics thermal management.

    Observation space (5-D continuous):
        [temperature, ambient_temp, heat_generation, current_fan_level, error]

    Action space (Discrete):
        Fan speed levels 0 … N-1  (len of fan_cooling_power list).

    Reward shaping:
        +1        if temperature is within the target band
        −0.1·|e|  for every °C outside the band
        −0.05·c   for fan energy cost (higher fan speeds penalised)
        +0.1      smoothness bonus for small action changes
        −50       critical temperature reached (episode terminates)
    """

    metadata = {"render_modes": ["human", "ansi"], "render_fps": 10}

    def __init__(
        self,
        config: dict[str, Any] | None = None,
        render_mode: str | None = None,
    ) -> None:
        super().__init__()
        cfg = config or {}
        env_cfg = cfg.get("environment", {})
        thermal = env_cfg.get("thermal", {})
        reward_cfg = env_cfg.get("reward", {})

        # ---------- thermal parameters --------------------------------
        self.ambient_base: float = thermal.get("ambient_temp", 25.0)
        self.target_temp: float = thermal.get("target_temp", 55.0)
        self.temp_tolerance: float = thermal.get("temp_tolerance", 5.0)
        self.critical_temp: float = thermal.get("critical_temp", 85.0)
        self.min_temp: float = thermal.get("min_temp", 15.0)

        self.thermal_mass: float = thermal.get("thermal_mass", 50.0)
        self.thermal_resistance: float = thermal.get("thermal_resistance", 1.5)
        self.heat_gen_base: float = thermal.get("heat_generation_base", 30.0)
        self.heat_gen_var: float = thermal.get("heat_generation_var", 15.0)
        self.fan_cooling: list[float] = thermal.get(
            "fan_cooling_power", [0.0, 5.0, 15.0, 30.0, 50.0]
        )
        self.fan_cost: list[float] = thermal.get(
            "fan_energy_cost", [0.0, 0.5, 1.5, 3.5, 7.0]
        )

        self.enable_disturbances: bool = thermal.get("enable_disturbances", True)
        self.disturbance_amp: float = thermal.get("disturbance_amplitude", 5.0)
        self.workload_freq: float = thermal.get("workload_frequency", 0.02)
        self.dt: float = thermal.get("dt", 1.0)

        # ---------- reward coefficients -------------------------------
        self.r_in_band: float = reward_cfg.get("temp_in_band", 1.0)
        self.r_deviation: float = reward_cfg.get("temp_deviation_penalty", -0.1)
        self.r_energy: float = reward_cfg.get("energy_penalty", -0.05)
        self.r_critical: float = reward_cfg.get("critical_penalty", -50.0)
        self.r_smooth: float = reward_cfg.get("smoothness_bonus", 0.1)

        self.max_steps: int = env_cfg.get("max_episode_steps", 500)

        # ---------- spaces --------------------------------------------
        n_actions = len(self.fan_cooling)
        self.action_space = spaces.Discrete(n_actions)

        # obs: [temp, ambient, heat_gen, fan_level_normalised, error]
        low = np.array([self.min_temp, 0.0, 0.0, 0.0, -100.0], dtype=np.float32)
        high = np.array([self.critical_temp + 20, 60.0, 100.0, 1.0, 100.0], dtype=np.float32)
        self.observation_space = spaces.Box(low=low, high=high, dtype=np.float32)

        self.render_mode = render_mode

        # ---------- state (set in reset) ------------------------------
        self.temperature: float = 0.0
        self.ambient_temp: float = 0.0
        self.heat_gen: float = 0.0
        self.fan_level: int = 0
        self._step_count: int = 0
        self._prev_action: int = 0
        self._rng: np.random.Generator | None = None

    # ==================================================================
    # Gymnasium interface
    # ==================================================================
    def reset(
        self,
        *,
        seed: int | None = None,
        options: dict | None = None,
    ) -> tuple[np.ndarray, dict[str, Any]]:
        super().reset(seed=seed)
        self._rng = np.random.default_rng(seed)

        # Initial state: temperature near target ± small noise
        self.temperature = self.target_temp + self._rng.uniform(-3, 3)
        self.ambient_temp = self.ambient_base
        self.heat_gen = self.heat_gen_base
        self.fan_level = 0
        self._step_count = 0
        self._prev_action = 0

        obs = self._get_obs()
        info = self._get_info()
        return obs, info

    # ------------------------------------------------------------------
    def step(
        self, action: int
    ) -> tuple[np.ndarray, float, bool, bool, dict[str, Any]]:
        assert self.action_space.contains(action), f"Invalid action {action}"
        self._step_count += 1

        # ---------- environment dynamics ------------------------------
        # Workload variation (sinusoidal + noise)
        t = self._step_count * self.dt
        workload_sin = self.heat_gen_var * np.sin(2 * np.pi * self.workload_freq * t)
        workload_noise = self._rng.normal(0, self.heat_gen_var * 0.1)
        self.heat_gen = max(0.0, self.heat_gen_base + workload_sin + workload_noise)

        # Ambient disturbances
        if self.enable_disturbances:
            self.ambient_temp = self.ambient_base + self._rng.uniform(
                -self.disturbance_amp, self.disturbance_amp
            )

        # Cooling from fan
        fan_cooling = self.fan_cooling[action]
        self.fan_level = action

        # Lumped-capacitance thermal ODE (forward Euler)
        passive_loss = (self.temperature - self.ambient_temp) / self.thermal_resistance
        dT = (self.heat_gen - passive_loss - fan_cooling) / self.thermal_mass * self.dt
        self.temperature += dT
        self.temperature = np.clip(self.temperature, self.min_temp, self.critical_temp + 10)

        # ---------- reward --------------------------------------------
        error = self.temperature - self.target_temp
        reward = self._compute_reward(error, action)

        # ---------- termination ---------------------------------------
        terminated = self.temperature >= self.critical_temp
        truncated = self._step_count >= self.max_steps

        obs = self._get_obs()
        info = self._get_info()
        info["error"] = float(error)

        self._prev_action = action
        return obs, reward, terminated, truncated, info

    # ------------------------------------------------------------------
    def _compute_reward(self, error: float, action: int) -> float:
        reward = 0.0

        # In-band bonus
        if abs(error) <= self.temp_tolerance:
            reward += self.r_in_band
        else:
            reward += self.r_deviation * (abs(error) - self.temp_tolerance)

        # Energy penalty
        reward += self.r_energy * self.fan_cost[action]

        # Smoothness bonus (small action change)
        action_change = abs(action - self._prev_action)
        if action_change <= 1:
            reward += self.r_smooth

        # Critical penalty
        if self.temperature >= self.critical_temp:
            reward += self.r_critical

        return reward

    # ------------------------------------------------------------------
    def _get_obs(self) -> np.ndarray:
        error = self.temperature - self.target_temp
        fan_norm = self.fan_level / max(len(self.fan_cooling) - 1, 1)
        return np.array(
            [self.temperature, self.ambient_temp, self.heat_gen, fan_norm, error],
            dtype=np.float32,
        )

    def _get_info(self) -> dict[str, Any]:
        return {
            "temperature": self.temperature,
            "ambient": self.ambient_temp,
            "heat_generation": self.heat_gen,
            "fan_level": self.fan_level,
            "step": self._step_count,
        }

    # ------------------------------------------------------------------
    def render(self) -> str | None:
        if self.render_mode == "ansi":
            err = self.temperature - self.target_temp
            band = "✓" if abs(err) <= self.temp_tolerance else "✗"
            line = (
                f"Step {self._step_count:4d} | "
                f"T={self.temperature:6.1f}°C | "
                f"Amb={self.ambient_temp:5.1f}°C | "
                f"Q={self.heat_gen:5.1f}W | "
                f"Fan={self.fan_level} | "
                f"Err={err:+5.1f}°C [{band}]"
            )
            print(line)
            return line
        return None
